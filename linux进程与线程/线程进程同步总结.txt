互斥锁
1.当访问共享资源时,用于实现多线程之间的互斥访问,加锁和解锁是在同一个线程中,
对资源的访问包括读和写,
获得锁的线程，直接对共享资源进行读和写
未获得锁的线程会阻塞休眠
当一个线程释放互斥锁时，多个阻塞线程获得锁的顺序是不确定的,先获得调度的线程先获得锁,进而对共享资源进行访问

应用例子:

信号量
信号量值初始化为1，效果和互斥锁一样，实现对资源的同步访问
当信号量的值大于1时，多线程中超过一个以上的线程可以访问共享资源
信号量的使用是在不同的线程中，就是一个线程释放信号量，一个线程获得信号量，进而线程得已执行
用计数器来表示资源的情况
比如生产者消费者场合
消费者消费计数
生产者补充计数

应用例子:

读写锁
用于多线程中，对资源的读写访问同步，任何时候，只能有一个线程进行写，进行读的时候，可以多个线程进行读，
适合用于读次数大于写次的场合

自旋锁
自旋锁，相当于把互斥锁对线程的阻塞，改成轮询,也就死等，这个时候线程是不会休眠的，直到获得锁为止，否则一直等待下去,通过top -H -p，可以查看到，
等待获得锁的线程，cpu利用率有点高，这样的好处是当有机会使用锁的时候，无需获唤醒线程，效率高，适合于短时间就能处理完业务的场合

条件变量
条件变量一般结合互斥锁来使用
有点像是互斥锁+信号量的结合体
条件满足时，线程执行，条件不满足时，线程阻塞
条件变量有一个好处是，可以广播，收到广播的线程，可以解除阻塞,得以执行

线程屏障
用于多个合作线程，当线程个数，不到初始值时，被执行的线程，会被阻塞，相当于进入一个队列里面进行休眠，
当执行的线程个数达到一初始的初始值时，线程就会按照先进先出的原则，一个一个地执行。
